<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        esc95 Blog
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            数组常用方法
        </p>
        <hr>
    </div>
    <div class="post-content">
        <blockquote>
<p>考虑到日常开发中使用比较频繁，为了方便查找与回顾，整理此文。</p>
</blockquote>
<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="# 基础篇"></a><a href="#">#</a> 基础篇</h1><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>concat()</td>
<td>连接两个或多个数组，并返回已连接数组的副本。</td>
</tr>
<tr>
<td>copyWithin()</td>
<td>将数组中的数组元素复制到指定位置或从指定位置复制。</td>
</tr>
<tr>
<td>entries()</td>
<td>返回键/值对数组迭代对象。</td>
</tr>
<tr>
<td>every()</td>
<td>检查数组中的每个元素是否通过测试。</td>
</tr>
<tr>
<td>fill()</td>
<td>用静态值填充数组中的元素。</td>
</tr>
<tr>
<td>filter()</td>
<td>使用数组中通过测试的每个元素创建新数组。</td>
</tr>
<tr>
<td>find()</td>
<td>返回数组中第一个通过测试的元素的值。</td>
</tr>
<tr>
<td>findIndex()</td>
<td>返回数组中通过测试的第一个元素的索引。</td>
</tr>
<tr>
<td>forEach()</td>
<td>为每个数组元素调用函数。</td>
</tr>
<tr>
<td>from()</td>
<td>从对象创建数组。</td>
</tr>
<tr>
<td>includes()</td>
<td>检查数组是否包含指定的元素。</td>
</tr>
<tr>
<td>indexOf()</td>
<td>在数组中搜索元素并返回其位置。</td>
</tr>
<tr>
<td>isArray()</td>
<td>检查对象是否为数组。</td>
</tr>
<tr>
<td>join()</td>
<td>将数组的所有元素连接成一个字符串。</td>
</tr>
<tr>
<td>keys()</td>
<td>返回 Array Iteration 对象，包含原始数组的键.</td>
</tr>
<tr>
<td>lastIndexOf()</td>
<td>在数组中搜索元素，从末尾开始，并返回其位置。</td>
</tr>
<tr>
<td>map()</td>
<td>使用为每个数组元素调用函数的结果创建新数组。</td>
</tr>
<tr>
<td>pop()</td>
<td>删除数组的最后一个元素，并返回该元素。</td>
</tr>
<tr>
<td>push()</td>
<td>将新元素添加到数组的末尾，并返回新的长度。</td>
</tr>
<tr>
<td>reduce()</td>
<td>将数组的值减为单个值（从左到右）。</td>
</tr>
<tr>
<td>reduceRight()</td>
<td>将数组的值减为单个值（从右到左）。</td>
</tr>
<tr>
<td>reverse()</td>
<td>反转数组中元素的顺序。</td>
</tr>
<tr>
<td>shift()</td>
<td>删除数组的第一个元素，并返回该元素。</td>
</tr>
<tr>
<td>slice()</td>
<td>选择数组的一部分，并返回新数组。</td>
</tr>
<tr>
<td>some()</td>
<td>检查数组中的任何元素是否通过测试。</td>
</tr>
<tr>
<td>sort()</td>
<td>对数组的元素进行排序。</td>
</tr>
<tr>
<td>splice()</td>
<td>从数组中添加/删除元素。</td>
</tr>
<tr>
<td>toString()</td>
<td>将数组转换为字符串，并返回结果。</td>
</tr>
<tr>
<td>unshift()</td>
<td>将新元素添加到数组的开头，并返回新的长度。</td>
</tr>
<tr>
<td>valueOf()</td>
<td>返回数组的原始值。</td>
</tr>
<tr>
<td>at()</td>
<td>2021.1 新提案，解决方括号的限制，可以输入负数。</td>
</tr>
</tbody></table>
<p>[TOC]</p>
<h2 id="1-1-求和"><a href="#1-1-求和" class="headerlink" title="# 1.1 求和"></a><a href="#">#</a> 1.1 求和</h2><h3 id="方法一：Array-prototype-forEach"><a href="#方法一：Array-prototype-forEach" class="headerlink" title="# 方法一：Array.prototype.forEach()"></a><a href="#">#</a> 方法一：Array.prototype.forEach()</h3><pre><code>var total = 0;
[1, 2, 3].forEach(function (num) &#123;
  total += num;
&#125;);
</code></pre>
<p>1<br>2<br>3<br>4</p>
<h3 id="方法二：Array-prototype-reduce"><a href="#方法二：Array-prototype-reduce" class="headerlink" title="# 方法二：Array.prototype.reduce()"></a><a href="#">#</a> 方法二：Array.prototype.reduce()</h3><pre><code>var total = [1, 2, 3].reduce(function (sum, current) &#123;
  return sum + current;
&#125;, 0);
</code></pre>
<p>1<br>2<br>3</p>
<h2 id="1-2-排序"><a href="#1-2-排序" class="headerlink" title="# 1.2 排序"></a><a href="#">#</a> 1.2 排序</h2><h3 id="方法一：sort"><a href="#方法一：sort" class="headerlink" title="# 方法一：sort()"></a><a href="#">#</a> 方法一：sort()</h3><pre><code>// 默认是升序
[1, 2, 3, 4].sort((a, b) =&gt; a - b); // [1, 2, 3, 4]
// 降序
[1, 2, 3, 4].sort((a, b) =&gt; b - a); // [4, 3, 2, 1]
</code></pre>
<p>1<br>2<br>3<br>4</p>
<h3 id="方法二：排序算法"><a href="#方法二：排序算法" class="headerlink" title="# 方法二：排序算法"></a><a href="#">#</a> 方法二：排序算法</h3><p><img src="https://gblobscdn.gitbook.com/assets%2F-Lm9JtwbhXVOfXyecToy%2F-Lm9KQIJAMvCgJQzErQS%2F-Lm9KSPi7v-ygMtlI6Zr%2Fsort.png?alt=media"></p>
<p>参考文献</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://sort.hust.cc/">十大经典排序算法 - Git Book (opens new window)</a></li>
<li>[JavaScript 数据结构与算法之美 - 十大经典排序算法 - 天明夜尽 (opens new window)](<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903902484103182">https://juejin.cn/post/6844903902484103182</a> target=)</li>
</ul>
<h2 id="1-3-取最大值"><a href="#1-3-取最大值" class="headerlink" title="# 1.3 取最大值"></a><a href="#">#</a> 1.3 取最大值</h2><h3 id="方法一：Math-max"><a href="#方法一：Math-max" class="headerlink" title="# 方法一：Math.max()"></a><a href="#">#</a> 方法一：Math.max()</h3><pre><code>Math.max() // -Infinity，即 -∞

Math.max(Infinity, -Infinity) // Infinity，即 ∞

Math.max(...[1, 2, 3, 4]) // 4

Math.max.apply(this, [1, 2, 3, 4]) // 4

[1, 2, 3, 4].reduce( (prev, cur,curIndex,arr)=&gt; &#123;
 return Math.max(prev,cur);
&#125;,0) // 4
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11</p>
<h2 id="1-4-判断是否包含某值"><a href="#1-4-判断是否包含某值" class="headerlink" title="# 1.4 判断是否包含某值"></a><a href="#">#</a> 1.4 判断是否包含某值</h2><h3 id="方法一：Array-includes"><a href="#方法一：Array-includes" class="headerlink" title="# 方法一：Array.includes()"></a><a href="#">#</a> 方法一：Array.includes()</h3><pre><code>[7, 8, 9].includes(4) // false
</code></pre>
<p>1</p>
<h3 id="方法二：Array-indexOf"><a href="#方法二：Array-indexOf" class="headerlink" title="# 方法二：Array.indexOf()"></a><a href="#">#</a> 方法二：Array.indexOf()</h3><pre><code>[7, 8, 9].indexOf(4) // -1 如果存在返回索引
[7, 8, 9].indexOf(9) // 2
</code></pre>
<p>1<br>2</p>
<h3 id="方法三：Array-find"><a href="#方法三：Array-find" class="headerlink" title="# 方法三：Array.find()"></a><a href="#">#</a> 方法三：Array.find()</h3><p>如果数组中无值返回 undefined</p>
<pre><code>[7, 8, 9].find((item) =&gt; item === 4) // undefined
[7, 8, 9].find((item) =&gt; item === 9) // 9
</code></pre>
<p>1<br>2</p>
<h3 id="方法四：Array-findIndex"><a href="#方法四：Array-findIndex" class="headerlink" title="# 方法四：Array.findIndex()"></a><a href="#">#</a> 方法四：Array.findIndex()</h3><p>如果数组中无值返回-1</p>
<pre><code>[7, 8, 9].findIndex((item)=&gt; item === 4) // -1
[7, 8, 9].findIndex((item)=&gt; item === 9) // 2
</code></pre>
<p>1<br>2</p>
<h2 id="1-5-某一项设置值"><a href="#1-5-某一项设置值" class="headerlink" title="# 1.5 某一项设置值"></a><a href="#">#</a> 1.5 某一项设置值</h2><h3 id="方法一：Array-splice"><a href="#方法一：Array-splice" class="headerlink" title="# 方法一：Array.splice()"></a><a href="#">#</a> 方法一：Array.splice()</h3><pre><code>arr = [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;]
arr.splice(3, 0, 3)
arr // [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, 3, &#39;dddd&#39;]
</code></pre>
<p>1<br>2<br>3</p>
<h2 id="1-6-每一项设置值"><a href="#1-6-每一项设置值" class="headerlink" title="# 1.6 每一项设置值"></a><a href="#">#</a> 1.6 每一项设置值</h2><h3 id="方法一：Array-fill"><a href="#方法一：Array-fill" class="headerlink" title="# 方法一：Array.fill()"></a><a href="#">#</a> 方法一：Array.fill()</h3><pre><code>[7,8,9,10,11,12].fill() // [undefined, undefined, undefined, undefined, undefined, undefined]
[7,8,9,10,11,12].fill(7) // [7, 7, 7, 7, 7, 7]
[7,8,9,10,11,12].fill(3, 2, 4) // [7, 8, 3, 3, 11, 12]
</code></pre>
<p>1<br>2<br>3</p>
<h3 id="方法二：Array-map"><a href="#方法二：Array-map" class="headerlink" title="# 方法二：Array.map()"></a><a href="#">#</a> 方法二：Array.map()</h3><pre><code>[7, 8, 9].map((item, idx) =&gt; item % 2) // [1, 0, 1]
[7, 8, 9].map((item, idx) =&gt; idx) // [0, 1, 2]
</code></pre>
<p>1<br>2</p>
<h2 id="1-7-每一项是否满足"><a href="#1-7-每一项是否满足" class="headerlink" title="# 1.7 每一项是否满足"></a><a href="#">#</a> 1.7 每一项是否满足</h2><h3 id="方法一：Array-every"><a href="#方法一：Array-every" class="headerlink" title="# 方法一：Array.every()"></a><a href="#">#</a> 方法一：Array.every()</h3><pre><code>[1,2,3].every(item=&gt;&#123;return item&gt;2&#125;) //false
</code></pre>
<p>1</p>
<h2 id="1-8-有一项满足"><a href="#1-8-有一项满足" class="headerlink" title="# 1.8 有一项满足"></a><a href="#">#</a> 1.8 有一项满足</h2><h3 id="方法一：Array-some"><a href="#方法一：Array-some" class="headerlink" title="# 方法一：Array.some()"></a><a href="#">#</a> 方法一：Array.some()</h3><pre><code>[1,2,3].some(item=&gt;&#123;return item&gt;2&#125;) //true
</code></pre>
<p>1</p>
<h1 id="贰。番外篇"><a href="#贰。番外篇" class="headerlink" title="# 贰。番外篇"></a><a href="#">#</a> 贰。番外篇</h1><h2 id="2-1-重写-Array-prototype-at"><a href="#2-1-重写-Array-prototype-at" class="headerlink" title="# 2.1 重写 Array .prototype. at()"></a><a href="#">#</a> 2.1 重写 Array .prototype. at()</h2><pre><code>// 兼容老浏览器的 MDN polyfill
// 注释：Polyfill 是一块代码（通常是 Web 上的 JavaScript），用来为旧浏览器提供它没有原生支持的较新的功能。
if (Array.prototype.at) &#123;
    Array.prototype.at = function (idx) &#123;
        return this[this.length + idx]
    &#125;
&#125;
arr = [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;]
arr.at(-1) // &#39;dddd&#39;
arr.at(-3) // &#39;bbbb&#39;
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p>
<h2 id="2-2-清空数组"><a href="#2-2-清空数组" class="headerlink" title="# 2.2 清空数组"></a><a href="#">#</a> 2.2 清空数组</h2><h3 id="方法一：Array-length"><a href="#方法一：Array-length" class="headerlink" title="# 方法一：Array.length"></a><a href="#">#</a> 方法一：Array.length</h3><p>最快</p>
<pre><code>arr = [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;]
arr1 = arr
arr // [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;]
arr1 // [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;]

arr.length = 0 // 0

arr // []
// 被引用的数组，也会被清空
arr1 // []
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p>
<h3 id="方法二：Array-splice"><a href="#方法二：Array-splice" class="headerlink" title="# 方法二：Array.splice()"></a><a href="#">#</a> 方法二：Array.splice()</h3><pre><code>arr = [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;]
arr1 = arr

arr.splice(0) // [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;]

arr // []
// 同上，被引用的也会被清空
arr1 // []
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</p>
<h3 id="方法三：直接赋予新数组"><a href="#方法三：直接赋予新数组" class="headerlink" title="# 方法三：直接赋予新数组[]"></a><a href="#">#</a> 方法三：直接赋予新数组[]</h3><p>最慢，且占用内存</p>
<pre><code>arr = [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;]
arr1 = arr

arr = [] // []

arr // []
// 被引用的数组，不会被清空
arr1 // [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;]
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</p>
<h2 id="2-3-扁平化"><a href="#2-3-扁平化" class="headerlink" title="# 2.3 扁平化"></a><a href="#">#</a> 2.3 扁平化</h2><pre><code>const arr = [1, [2, [3, [4, 5]]], 6];
// =&gt; [1, 2, 3, 4, 5, 6]
</code></pre>
<p>1<br>2</p>
<h3 id="方法一：Array-prototype-flat"><a href="#方法一：Array-prototype-flat" class="headerlink" title="# 方法一：Array.prototype.flat()"></a><a href="#">#</a> 方法一：Array.prototype.flat()</h3><pre><code>const res1 = arr.flat(Infinity);
</code></pre>
<p>1</p>
<h3 id="方法二：new-RegExp"><a href="#方法二：new-RegExp" class="headerlink" title="# 方法二：new RegExp()"></a><a href="#">#</a> 方法二：new RegExp()</h3><pre><code>// 缺点：都会变成字符串
const res2 = JSON.stringify(arr).replace(/\[|\]/g, &#39;&#39;).split(&#39;,&#39;);
// 改良版
const res3 = JSON.parse(&#39;[&#39; + JSON.stringify(arr).replace(/\[|\]/g, &#39;&#39;) + &#39;]&#39;);
</code></pre>
<p>1<br>2<br>3<br>4</p>
<h3 id="方法三：Array-prototype-reduce"><a href="#方法三：Array-prototype-reduce" class="headerlink" title="# 方法三：Array.prototype.reduce()"></a><a href="#">#</a> 方法三：Array.prototype.reduce()</h3><pre><code>const flatten = arr =&gt; &#123;
  return arr.reduce((pre, cur) =&gt; &#123;
    return pre.concat(Array.isArray(cur) ? flatten(cur) : cur);
  &#125;, [])
&#125;
const res4 = flatten(arr);
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>6</p>
<h3 id="方法四：函数递归"><a href="#方法四：函数递归" class="headerlink" title="# 方法四：函数递归"></a><a href="#">#</a> 方法四：函数递归</h3><pre><code>const res5 = [];
const fn = arr =&gt; &#123;
  for (let i = 0; i &lt; arr.length; i++) &#123;
    if (Array.isArray(arr[i])) &#123;
      fn(arr[i]);
    &#125; else &#123;
      res5.push(arr[i]);
    &#125;
  &#125;
&#125;
fn(arr);
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11</p>
<h3 id="方法五：while-some"><a href="#方法五：while-some" class="headerlink" title="# 方法五：while() + some()"></a><a href="#">#</a> 方法五：while() + some()</h3><pre><code>function flatten(arr) &#123;
    while(arr.some(item=&gt;Array.isArray(item))) &#123;
        arr = [].concat(...arr);
    &#125;
    return arr;
&#125;
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>6</p>
<h2 id="2-4-合并"><a href="#2-4-合并" class="headerlink" title="# 2.4 合并"></a><a href="#">#</a> 2.4 合并</h2><h3 id="方法一：Array-push"><a href="#方法一：Array-push" class="headerlink" title="# 方法一：Array.push()"></a><a href="#">#</a> 方法一：Array.push()</h3><pre><code>const arr = [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;]
arr.push(1, 2, 3,[4, 5, 6]) // 8
arr // [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;, 1, 2, 3, Array(3)]
</code></pre>
<p>1<br>2<br>3</p>
<h3 id="方法二：Array-concat"><a href="#方法二：Array-concat" class="headerlink" title="# 方法二：Array.concat()"></a><a href="#">#</a> 方法二：Array.concat()</h3><pre><code>arr.concat([1, 2, 3],[4, 5, 6]) // [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;, 1, 2, 3, 4, 5, 6]
arr // [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;]
</code></pre>
<p>1<br>2</p>
<h3 id="方法二：扩展运算符"><a href="#方法二：扩展运算符" class="headerlink" title="# 方法二：扩展运算符"></a><a href="#">#</a> 方法二：扩展运算符</h3><pre><code>[...[1, 2, 3, 4],...[4, 5]] //[1,2,3,4,5,6]
</code></pre>
<p>1</p>
<h2 id="2-5-去重"><a href="#2-5-去重" class="headerlink" title="# 2.5 去重"></a><a href="#">#</a> 2.5 去重</h2><pre><code>const arr = [1, 1, &#39;1&#39;, 17, true, true, false, false, &#39;true&#39;, &#39;a&#39;, &#123;&#125;, &#123;&#125;];
// =&gt; [1, &#39;1&#39;, 17, true, false, &#39;true&#39;, &#39;a&#39;, &#123;&#125;, &#123;&#125;]
</code></pre>
<p>1<br>2</p>
<h3 id="方法一：new-Set"><a href="#方法一：new-Set" class="headerlink" title="# 方法一：new Set()"></a><a href="#">#</a> 方法一：new Set()</h3><pre><code>const arr1 = Array.from(new Set(arr));
// 或
const arr1 = [...new Set(arr)];

// 是 Set 类型，不是 Array 类型
Object.prototype.toString.call(new Set(arr)) // &#39;[object Set]&#39;
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>6</p>
<h3 id="方法二：filter-indexOf"><a href="#方法二：filter-indexOf" class="headerlink" title="# 方法二：filter() + indexOf()"></a><a href="#">#</a> 方法二：filter() + indexOf()</h3><pre><code>const arr2 = arr =&gt; &#123;
  return arr.filter((item, index) =&gt; &#123;
    return arr.indexOf(item) === index;
  &#125;);
&#125;
</code></pre>
<p>1<br>2<br>3<br>4<br>5</p>
<h3 id="方法三：new-Map"><a href="#方法三：new-Map" class="headerlink" title="# 方法三：new Map()"></a><a href="#">#</a> 方法三：new Map()</h3><pre><code>const arr3 = arr =&gt; &#123;
  const map = new Map();
  const res = [];
  for (let i = 0; i &lt; arr.length; i++) &#123;
    if (!map.has(arr[i])) &#123;
      map.set(arr[i], true)
      res.push(arr[i]);
    &#125;
  &#125;
  return res;
&#125;
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11</p>
<h3 id="方法四：includes"><a href="#方法四：includes" class="headerlink" title="# 方法四：includes()"></a><a href="#">#</a> 方法四：includes()</h3><pre><code>const arr4 = arr =&gt; &#123;
  const res = [];
  for (let i = 0; i &lt; arr.length; i++) &#123;
    if (!res.includes(arr[i])) res.push(arr[i]);
  &#125;
  return res;
&#125;
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7</p>
<h2 id="2-6-交集"><a href="#2-6-交集" class="headerlink" title="# 2.6 交集"></a><a href="#">#</a> 2.6 交集</h2><h3 id="方法一：new-Set-1"><a href="#方法一：new-Set-1" class="headerlink" title="# 方法一：new Set()"></a><a href="#">#</a> 方法一：new Set()</h3><pre><code>const one = [0, 2, 4, 6, 8, 8]
const two = [1, 2, 3, 4, 5, 6]
const duplicated = [...new Set(one)].filter(v =&gt; two.includes(v)) // [2, 4, 6]
</code></pre>
<p>1<br>2<br>3</p>
<h2 id="2-7-删除虚值"><a href="#2-7-删除虚值" class="headerlink" title="# 2.7 删除虚值"></a><a href="#">#</a> 2.7 删除虚值</h2><h3 id="方法一：Array-prototype-filter"><a href="#方法一：Array-prototype-filter" class="headerlink" title="# 方法一：Array.prototype.filter()"></a><a href="#">#</a> 方法一：Array.prototype.filter()</h3><pre><code>const arr = [0, &#39;blue&#39;, &#39;&#39;, NaN, 9, true, undefined, &#39;while&#39;, false]
const real = arr.filter(Boolean) // [&#39;blue&#39;, 9, true, &#39;while&#39;]
</code></pre>
<p>1<br>2</p>
<h2 id="2-8-重组（变量交换）"><a href="#2-8-重组（变量交换）" class="headerlink" title="# 2.8 重组（变量交换）"></a><a href="#">#</a> 2.8 重组（变量交换）</h2><h3 id="方法一：解构赋值"><a href="#方法一：解构赋值" class="headerlink" title="# 方法一：解构赋值"></a><a href="#">#</a> 方法一：解构赋值</h3><pre><code>arr = [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;, &#39;eee&#39;, &#39;fff&#39;]
[arr[1], arr[2]] = [arr[2], arr[1]] // [&#39;cccc&#39;, &#39;bbbb&#39;]
arr // [&#39;aaa&#39;, &#39;cccc&#39;, &#39;bbbb&#39;, &#39;dddd&#39;]

// 如果想获取单个值
[a, , , e, f] = arr
a // &#39;aaa&#39;
e // &#39;dddd&#39;
f // &#39;eee&#39;
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</p>
<h3 id="方法二：Array-splice-1"><a href="#方法二：Array-splice-1" class="headerlink" title="# 方法二：Array.splice()"></a><a href="#">#</a> 方法二：Array.splice()</h3><pre><code>arr = [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;, &#39;eee&#39;, &#39;fff&#39;, &#39;ggg&#39;, &#39;hhh&#39;, &#39;iii&#39;]
arr.splice(1, 3, ...arr.splice(4, 4, arr[1], arr[2], arr[3])) // [&#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;]
arr // [&#39;aaa&#39;, &#39;eee&#39;, &#39;fff&#39;, &#39;ggg&#39;, &#39;hhh&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;, &#39;iii&#39;]
</code></pre>
<p>1<br>2<br>3</p>
<h3 id="方法三：引入中转变量"><a href="#方法三：引入中转变量" class="headerlink" title="# 方法三：引入中转变量"></a><a href="#">#</a> 方法三：引入中转变量</h3><pre><code>temp = arr[1]
arr[1] = arr[2]
arr[2] = temp
</code></pre>
<p>1<br>2<br>3</p>
<h2 id="2-9-类数组-–-gt-数组"><a href="#2-9-类数组-–-gt-数组" class="headerlink" title="# 2.9 类数组 –&gt; 数组"></a><a href="#">#</a> 2.9 类数组 –&gt; 数组</h2><pre><code>// 类数组（包含 length 属性，比如 arguments、DOM 操作方法返回的结果等）
const asArr = &#123; 0: &#39;aaa&#39;, &#39;1&#39;: &#39;bbb&#39;, &#39;二&#39;: &#39;ccc&#39;, 4: &#39;eee&#39;, length: 6 &#125;
</code></pre>
<p>1<br>2</p>
<h3 id="方法一：Array-prototype-from"><a href="#方法一：Array-prototype-from" class="headerlink" title="# 方法一：Array.prototype.from()"></a><a href="#">#</a> 方法一：Array.prototype.from()</h3><pre><code>Array.from(asArr)
// =&gt; [&#39;aaa&#39;, &#39;bbb&#39;, undefined, undefined, &#39;eee&#39;, undefined]
// undefined 可枚举
</code></pre>
<p>1<br>2<br>3</p>
<h3 id="方法二：Array-prototype-slice-call"><a href="#方法二：Array-prototype-slice-call" class="headerlink" title="# 方法二：Array.prototype.slice.call()"></a><a href="#">#</a> 方法二：Array.prototype.slice.call()</h3><pre><code>Array.prototype.slice.call(asArr)
// =&gt; [&#39;aaa&#39;, &#39;bbb&#39;, empty × 2, &#39;eee&#39;, empty]
// empty 不可枚举
</code></pre>
<p>1<br>2<br>3</p>
<p>PS：其他产生 empty 的情况</p>
<pre><code>// 也会产生 empty 空位，不会改变 length 属性
delete arr[2]
// 直接删掉元素，且改变 length 属性
arr.splice(2, 1)
</code></pre>
<p>1<br>2<br>3<br>4</p>
<h3 id="方法三：扩展运算符"><a href="#方法三：扩展运算符" class="headerlink" title="# 方法三：扩展运算符"></a><a href="#">#</a> 方法三：扩展运算符</h3><pre><code>[...document.querySelectorAll(&#39;div&#39;)]
</code></pre>
<p>1</p>
<h2 id="2-10-数组-–-gt-对象"><a href="#2-10-数组-–-gt-对象" class="headerlink" title="# 2.10 数组 –&gt; 对象"></a><a href="#">#</a> 2.10 数组 –&gt; 对象</h2><h3 id="方法一：扩展运算符"><a href="#方法一：扩展运算符" class="headerlink" title="# 方法一：扩展运算符"></a><a href="#">#</a> 方法一：扩展运算符</h3><pre><code>arr = [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;]
// [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;]
&#123; ...arr &#125;
// &#123;0: &#39;aaa&#39;, 1: &#39;bbbb&#39;, 2: &#39;cccc&#39;, 3: &#39;dddd&#39;&#125;
</code></pre>
<p>1<br>2<br>3<br>4</p>
<h3 id="方法二：while"><a href="#方法二：while" class="headerlink" title="# 方法二：while()"></a><a href="#">#</a> 方法二：while()</h3><pre><code>i = 0
s = &#123;&#125;
arr = [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;]

while (arr[i]) &#123;
    s[i] = arr[i++]
&#125;

s // &#123;0: &#39;aaa&#39;, 1: &#39;bbbb&#39;, 2: &#39;cccc&#39;, 3: &#39;dddd&#39;&#125;
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</p>
<h3 id="方法三：Object-fromEntries"><a href="#方法三：Object-fromEntries" class="headerlink" title="# 方法三：Object.fromEntries()"></a><a href="#">#</a> 方法三：Object.fromEntries()</h3><pre><code>Object.keys(&#123;name:&#39;张三&#39;,age:14&#125;) // [&#39;name&#39;,&#39;age&#39;]
Object.values(&#123;name:&#39;张三&#39;,age:14&#125;) // [&#39;张三&#39;,14]
Object.entries(&#123;name:&#39;张三&#39;,age:14&#125;) // [[name,&#39;张三&#39;],[age,14]]
Object.fromEntries([name,&#39;张三&#39;],[age,14]) // ES10的api,Chrome不支持, firebox输出&#123;name:&#39;张三&#39;,age:14&#125;
</code></pre>
<p>1<br>2<br>3<br>4</p>
<h2 id="2-11-浅拷贝"><a href="#2-11-浅拷贝" class="headerlink" title="# 2.11 浅拷贝"></a><a href="#">#</a> 2.11 浅拷贝</h2><h3 id="方法一：Array-slice"><a href="#方法一：Array-slice" class="headerlink" title="# 方法一：Array.slice()"></a><a href="#">#</a> 方法一：Array.slice()</h3><pre><code>arr = [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;]
arr1 = arr.slice(0)
arr[1] = 2333 // 2333
arr // [&#39;aaa&#39;, 2333, &#39;cccc&#39;, &#39;dddd&#39;]
arr1 // [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;]
</code></pre>
<p>1<br>2<br>3<br>4<br>5</p>
<h3 id="方法二：展开操作符"><a href="#方法二：展开操作符" class="headerlink" title="# 方法二：展开操作符"></a><a href="#">#</a> 方法二：展开操作符</h3><pre><code>arr = [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;]
arr1 = [...arr]
arr[1] = 2333 // 2333
arr // [&#39;aaa&#39;, 2333, &#39;cccc&#39;, &#39;dddd&#39;]
arr1 // [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;]
</code></pre>
<p>1<br>2<br>3<br>4<br>5</p>
<h3 id="方法三：Array-concat"><a href="#方法三：Array-concat" class="headerlink" title="# 方法三：Array.concat()"></a><a href="#">#</a> 方法三：Array.concat()</h3><pre><code>arr = [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;]
arr1 = [].concat(array)
arr[1] = 2333 // 2333
arr // [&#39;aaa&#39;, 2333, &#39;cccc&#39;, &#39;dddd&#39;]
arr1 // [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;]
</code></pre>
<p>1<br>2<br>3<br>4<br>5</p>
<h3 id="方法四：直接赋值"><a href="#方法四：直接赋值" class="headerlink" title="# 方法四：直接赋值"></a><a href="#">#</a> 方法四：直接赋值</h3><pre><code>arr = [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;]
arr1 = arr
arr[1] = 2333 // 2333
arr // [&#39;aaa&#39;, 2333, &#39;cccc&#39;, &#39;dddd&#39;]
arr1 // [&#39;aaa&#39;, 2333, &#39;cccc&#39;, &#39;dddd&#39;]
</code></pre>
<p>1<br>2<br>3<br>4<br>5</p>
<h2 id="2-12-Array-from-达到-map-的效果"><a href="#2-12-Array-from-达到-map-的效果" class="headerlink" title="# 2.12 Array.from 达到 .map 的效果"></a><a href="#">#</a> 2.12 Array.from 达到 .map 的效果</h2><pre><code>arr = [
    &#123; name: &#39;张三&#39;, age: 18 &#125;,
    &#123; name: &#39;李四&#39;, age: 18 &#125;,
    &#123; name: &#39;王麻子&#39;, age: 18 &#125;,
    &#123; name: &#39;小六&#39;, age: 18 &#125;,
]
nameMap = arr.map(v =&gt; v.name) // [&#39;张三&#39;, &#39;李四&#39;, &#39;王麻子&#39;, &#39;小六&#39;]
nameMap = Array.from(arr, (&#123;name&#125;) =&gt; name) // [&#39;张三&#39;, &#39;李四&#39;, &#39;王麻子&#39;, &#39;小六&#39;]
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</p>
<h2 id="2-13-获取最后-n-个元素"><a href="#2-13-获取最后-n-个元素" class="headerlink" title="# 2.13 获取最后 n 个元素"></a><a href="#">#</a> 2.13 获取最后 n 个元素</h2><h3 id="方法一：Array-splice-1"><a href="#方法一：Array-splice-1" class="headerlink" title="# 方法一：Array.splice()"></a><a href="#">#</a> 方法一：Array.splice()</h3><pre><code>arr = [&#39;aaa&#39;, &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;]

arr.slice().splice(-1) // [&#39;dddd&#39;]
arr.slice().splice(-3) // &#39;bbbb&#39;, &#39;cccc&#39;, &#39;dddd&#39;
</code></pre>
<p>1<br>2<br>3<br>4</p>
<h2 id="2-233-二维数组绘制图形"><a href="#2-233-二维数组绘制图形" class="headerlink" title="# 2.233 二维数组绘制图形"></a><a href="#">#</a> 2.233 二维数组绘制图形</h2><h3 id="方法一：Emmm"><a href="#方法一：Emmm" class="headerlink" title="# 方法一：Emmm"></a><a href="#">#</a> 方法一：Emmm</h3><pre><code>// Emmmm
</code></pre>
<p>1</p>
<h1 id="弎。循环的性能与小优化"><a href="#弎。循环的性能与小优化" class="headerlink" title="# 弎。循环的性能与小优化"></a><a href="#">#</a> 弎。循环的性能与小优化</h1><h2 id="优化一：优化-for-循环"><a href="#优化一：优化-for-循环" class="headerlink" title="# 优化一：优化 for 循环"></a><a href="#">#</a> 优化一：优化 for 循环</h2><ul>
<li>当循环复杂度为 <code>O(n)</code> 时，<code>减少每次迭代的工作量</code>是最有效的方法。</li>
<li>当复杂度大于 <code>O(n)</code> 时，建议着重<code>减少迭代次数</code>。</li>
</ul>
<h3 id="a-减少每次取-length-的次数"><a href="#a-减少每次取-length-的次数" class="headerlink" title="# a. 减少每次取 length 的次数"></a><a href="#">#</a> a. 减少每次取 length 的次数</h3><p>这样避免了每次执行循环都要先去找 array.length</p>
<pre><code>for (let i = 0; i &lt; array.length; i++) &#123;
    console.log(i) // 0 1 2
&#125;

// 优化后
for (let i = 0, len = array.length; i &lt; len; i++) &#123;
    console.log(i) // 0 1 2
    // do sth...
&#125;
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</p>
<h3 id="b-倒序循环"><a href="#b-倒序循环" class="headerlink" title="# b. 倒序循环"></a><a href="#">#</a> b. 倒序循环</h3><pre><code>for (let i = array.length; i &gt; 0; i--) &#123;
    console.log(i) // 3 2 1
&#125;

// 优化后
for (let i = array.length - 1; i &gt;= 0; i--) &#123;
    console.log(i) // 2 1 0
&#125;

// 优化后
for (let i = array.length; i--;) &#123;
    console.log(i) // 2 1 0
    // do sth...
&#125;
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14</p>
<h2 id="优化二：不要使用-for-in-来遍历数组"><a href="#优化二：不要使用-for-in-来遍历数组" class="headerlink" title="# 优化二：不要使用 for-in 来遍历数组"></a><a href="#">#</a> 优化二：不要使用 for-in 来遍历数组</h2><p>在 JavaScript 提供的循环类型中，只有 for-in 循环比其他几种明显要慢。</p>
<p>由于每次迭代操作会同时搜索实例或原型属性，for-in 循环的每次迭代都会产生更多开销，所以比其他循环类型要慢。</p>
<p>因此，除非你明确需要迭代一个属性数量未知的对象，否则应避免使用 for-in 循环。</p>
<h2 id="优化三：慎用基于函数的迭代"><a href="#优化三：慎用基于函数的迭代" class="headerlink" title="# 优化三：慎用基于函数的迭代"></a><a href="#">#</a> 优化三：慎用基于函数的迭代</h2><p>例如：forEach</p>
<p>基于函数的迭代提供了一个更为便利的迭代方法，但它仍然比基于循环的迭代<code>要慢一些</code>。<code>对每个数组调用外部方法所带来的开销</code>是速度慢的主要原因。在所有情况下，基于循环的迭代比基于函数的迭代快<code>8倍</code>，因此在运行速度要求严格时，基于函数的迭代不是更好的选择。</p>
<h2 id="优化四：尽量使用-switch-case-条件语句"><a href="#优化四：尽量使用-switch-case-条件语句" class="headerlink" title="# 优化四：尽量使用 switch-case 条件语句"></a><a href="#">#</a> 优化四：尽量使用 switch-case 条件语句</h2><p>除非在<code>非真既假</code>的判断中，其余条件判断时多用 switch-case 语句，少用 if/else-if/else 语句。原因如下：</p>
<ul>
<li>支持关联操作，即不写 break 语句</li>
<li>本质是汇编时生成的跳转表来指示 case 的地址，所以每一个 case 的执行时间基本是相同的，执行效率不会受先后顺序的影响</li>
<li>代码更清晰，可读性和可维护性要高很多</li>
</ul>
<h2 id="优化五：查找表"><a href="#优化五：查找表" class="headerlink" title="# 优化五：查找表"></a><a href="#">#</a> 优化五：查找表</h2><p>当有大量离散数据的时候，使用查找表比使用 if-else 和 switch-case 快得多。</p>
<pre><code>// 将返回值集合存入数组
const results = [result0, result1, result2, result3, result4]

// 返回结果
return results[value]
</code></pre>
<p>1<br>2<br>3<br>4<br>5</p>
<h1 id="肆。课外题"><a href="#肆。课外题" class="headerlink" title="# 肆。课外题"></a><a href="#">#</a> 肆。课外题</h1><h2 id="箭头函数的输出"><a href="#箭头函数的输出" class="headerlink" title="# 箭头函数的输出"></a><a href="#">#</a> 箭头函数的输出</h2><pre><code>var func1 = x =&gt; x
func1(2) // 2
var func2 = x =&gt; &#123;x&#125;
func2(2) // undefined
var func3 = x =&gt; (&#123;x&#125;)
func3() // &#123;x: undefined&#125;
func3(2) // &#123;x: 2&#125;
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7</p>

    </div>

    
</div>
    <div class="footer" id="footer">

</div>
<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="">
<input type="hidden" id="valine_appKey" value="">

<script src="/libs/jquery.min.js"></script>

    
<script src="/libs/highlight/highlight.pack.js"></script>

        <script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
        
<script src="/js/js.js"></script>

            <style type="text/css">
                .v * {
                    color: #698fca;
                }

                .v .vlist .vcard .vhead .vsys {
                    color: #3a3e4a;
                }

                .v .vlist .vcard .vh .vmeta .vat {
                    color: #638fd5;
                }

                .v .vlist .vcard .vhead .vnick {
                    color: #6ba1ff;
                }

                .v a {
                    color: #8696b1;
                }

                .v .vlist .vcard .vhead .vnick:hover {
                    color: #669bfc;
                }
            </style>
</body>

</html>